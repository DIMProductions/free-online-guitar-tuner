<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>ΔPhase Mobile Web Tuner</title>
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <meta name="description" content="Mobile-friendly web tuner with chromatic mode and guitar tuning presets.">

  <style>
  * {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
  }

  body {
    height: 100vh;
    background: radial-gradient(ellipse at 30% 30%, #000 0%, #000 50%, #000 100%);
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    font-family: ui-monospace, "SF Mono", Menlo, Consolas, monospace;
    color: #e8f7ff;
  }

  .meter-pane,
  .circle-meter-container {
    position: relative;
    width: min(70vmin, 520px);
    aspect-ratio: 1;
  }

  .hud-canvas {
    position: absolute;
    inset: 0;
    width: 100%;
    height: 100%;
    display: block;
    filter: drop-shadow(0 0 18px rgba(43,108,255,0.45));
    z-index: 1;
  }

  .hud-ring {
    position: absolute;
    inset: 0;
    display: grid;
    place-items: center;
    pointer-events: none;
    filter: drop-shadow(0 0 10px rgba(0,255,255,0.12));
    z-index: 0;
  }

  .hud-ring > svg {
    width: 100%;
    height: 100%;
    display: block;
    transform-origin: 50% 50%;
    transform: scale(0.98);
  }

  .control-strip {
    width: 100%;
    max-width: 520px;
    margin-top: 20px;
    padding: 10px 12px 14px;
    border-radius: 18px;
    background:
      radial-gradient(circle at 0 0, rgba(0,180,255,0.12) 0, transparent 45%),
      radial-gradient(circle at 100% 100%, rgba(255,100,180,0.08) 0, transparent 50%),
      linear-gradient(135deg, #020712 0%, #050b16 50%, #020509 100%);
    border: 1px solid rgba(0,255,255,0.2);
    box-shadow:
      0 0 0 1px rgba(0,0,0,0.9),
      0 16px 40px rgba(0,0,0,0.85);
    display: flex;
    flex-direction: column;
    align-items: stretch;
    gap: 6px;
  }

  .tuning-row {
    display: flex;
    align-items: center;
    justify-content: space-between;
    gap: 8px;
    margin-bottom: 4px;
  }

  .tuning-label {
    font-size: 11px;
    text-transform: uppercase;
    letter-spacing: 0.12em;
    color: #5fa2b8;
  }

  #tuningSelect {
    flex: 1;
    padding: 5px 10px;
    border-radius: 999px;
    border: 1px solid rgba(0,255,255,0.35);
    background: radial-gradient(circle at 0 0, #021019 0, #01060a 55%, #000 100%);
    color: #d8f3ff;
    font-size: 11px;
    outline: none;
    appearance: none;
  }

  #startBtn {
    margin-top: 2px;
    padding: 8px 18px;
    border-radius: 999px;
    border: 1px solid rgba(0,255,255,0.7);
    background:
      radial-gradient(circle at 30% 0%, #0b2f4a 0, #021017 42%, #000 100%);
    color: #e8f7ff;
    font-size: 13px;
    letter-spacing: 0.09em;
    text-transform: uppercase;
    text-shadow: 0 0 6px rgba(0,255,255,0.7);
    box-shadow:
      0 0 12px rgba(0,255,255,0.6),
      0 0 36px rgba(0,140,255,0.35);
    cursor: pointer;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    gap: 6px;
  }

  #startBtn:hover:not(:disabled) {
    box-shadow:
      0 0 16px rgba(0,255,255,0.85),
      0 0 42px rgba(0,140,255,0.5);
    transform: translateY(-0.5px);
  }

  #startBtn:disabled {
    opacity: 0.45;
    cursor: not-allowed;
    transform: none;
    box-shadow: none;
  }

  #status {
    font-size: 12px;
    color: #79bcd1;
    text-align: center;
  }

  #metrics {
    margin-top: 4px;
    font-size: 10px;
    color: #5a8a9a;
    text-align: center;
    font-family: ui-monospace, monospace;
    white-space: pre;
  }

  @media (max-width: 600px) {
    body {
      height: 100vh;
      padding: 12px 8px;
      justify-content: flex-start;
      gap: 16px;
    }

    .meter-pane,
    .circle-meter-container {
      width: 100%;
      max-width: 420px;
    }

    .control-strip {
      max-width: 420px;
      margin-top: 12px;
      padding: 8px 10px 10px;
      border-radius: 16px;
      gap: 4px;
    }

    #startBtn {
      width: 100%;
      font-size: 12px;
      padding: 9px 10px;
    }

    #status {
      font-size: 11px;
    }

    #metrics {
      font-size: 9px;
    }
  }
  </style>
</head>
<body>

<div class="meter-pane">
  <div class="circle-meter-container">
    <canvas class="hud-canvas" id="hudCanvas"></canvas>
    <div class="hud-ring">
      <!-- HUD SVG を入れるならここ -->
    </div>
  </div>
</div>

<div class="control-strip">
  <div class="tuning-row">
    <div class="tuning-label">TUNING</div>
    <select id="tuningSelect">
      <option value="chromatic">Chromatic (any note)</option>
      <option value="gtr_std">Guitar - Standard (EADGBE)</option>
      <option value="gtr_drop_csharp" selected>Guitar - Drop C# (C# G# C# F# A# C#)</option>
    </select>
  </div>

  <button id="startBtn">TAP TO START TUNER</button>
  <div id="status">Idle</div>
  <div id="metrics"></div>
</div>

<!-- ===== Circle HUD 描画 ===== -->
<script>
(function(){
  'use strict';

  const NOTE = ['C','C#','D','D#','E','F','F#','G','G#','A','A#','B'];
  const a4 = 440.0;
  const MAX_CENTS = 50;
  const MAX_ANG   = 60 * Math.PI / 180;
  const BASE_ANG  = -Math.PI / 2;

  const canvas = document.getElementById('hudCanvas');
  if (!canvas) return;

  const DPR = Math.min(1.75, window.devicePixelRatio || 1);
  const ctx = canvas.getContext('2d');

  function fit(){
    const r = canvas.getBoundingClientRect();
    canvas.width  = r.width  * DPR;
    canvas.height = r.height * DPR;
    ctx.setTransform(DPR,0,0,DPR,0,0);
  }
  fit();
  window.addEventListener('resize', fit);

  function clamp(v, lo, hi){ return Math.max(lo, Math.min(hi, v)); }
  function lowpass(prev, next, dt, hz){
    const a = 1 - Math.exp(-dt * hz * 2 * Math.PI);
    return prev + (next - prev) * clamp(a, 0, 1);
  }
  function isInRange(c){ return Math.abs(c) <= 5; }
  function RGBA(c, a){ return `rgba(${c.r},${c.g},${c.b},${a})`; }

  // HUD が読むグローバル
  window.tunerFreq  = 440;
  window.tunerNote  = 'A4';
  window.tunerCents = 0;
  window.dpConfEMA  = 0;
  window.dpLocked   = false;

  window.setTunerState = function(freq, noteLabel, cents){
    if (!Number.isFinite(freq) || freq <= 0) return;
    window.tunerFreq  = freq;
    window.tunerNote  = noteLabel || '';
    window.tunerCents = cents || 0;
  };

  function getFreq() { return window.tunerFreq || 440; }

  let tPrev   = performance.now();
  let centsSm = 0;

  const centsSamples = [];
  const MAX_SAMPLES = 9;

  function pushCentsSample(c, conf){
    if (conf < 0.2) {
      centsSamples.length = 0;
      return;
    }
    centsSamples.push(c);
    if (centsSamples.length > MAX_SAMPLES) {
      centsSamples.shift();
    }
  }

  function getSmoothedCents(){
    if (centsSamples.length === 0) return 0;
    let sum = 0;
    for (let i = 0; i < centsSamples.length; i++){
      sum += centsSamples[i];
    }
    return sum / centsSamples.length;
  }

  let lockState       = "idle";
  let lockEnterTime   = 0;
  let lockLastGoodTime= 0;

  function updateLock(nowMs, baseLock, conf){
    const ok = baseLock && conf >= 0.20;
    if (ok) lockLastGoodTime = nowMs;

    if (lockState === "idle") {
      if (ok) {
        lockState = "locking";
        lockEnterTime = nowMs;
      }
    } else if (lockState === "locking") {
      if (!ok) {
        lockState = "idle";
      } else if (nowMs - lockEnterTime > 80) {
        lockState = "locked";
      }
    } else if (lockState === "locked") {
      if (nowMs - lockLastGoodTime > 400) {
        lockState = "idle";
      }
    }
    return lockState === "locked";
  }

  function draw(){
    const tNow = performance.now();
    const dt   = (tNow - tPrev) / 1000;
    tPrev = tNow;

    const freq  = getFreq();
    const noteL = window.tunerNote || '';
    const cents = window.tunerCents || 0;

    const w = canvas.width / DPR;
    const h = canvas.height / DPR;
    const cx = w * 0.5;
    const cy = h * 0.5;
    const r  = Math.min(w, h) * 0.46;

    const conf = clamp(window.dpConfEMA || 0, 0, 1);

    const rawCents = clamp(cents, -MAX_CENTS, MAX_CENTS);
    pushCentsSample(rawCents, conf);
    const smoothCents = getSmoothedCents();

    centsSm = lowpass(centsSm, smoothCents, dt, 4);

    const ang = (centsSm / MAX_CENTS) * MAX_ANG;
    const baseLock = Math.abs(centsSm) <= 8;
    const locked = updateLock(tNow, baseLock, conf);

    window.dpLocked = locked;

    ctx.clearRect(0,0,w,h);
    ctx.save();
    ctx.translate(cx, cy);

    const grad = ctx.createRadialGradient(0,0,r*0.2, 0,0,r*0.95);
    grad.addColorStop(0.0, 'rgba(0, 10, 18, 1)');
    grad.addColorStop(0.4, 'rgba(2, 36, 64, 1)');
    grad.addColorStop(0.7, 'rgba(0, 0, 0, 1)');
    grad.addColorStop(1.0, 'rgba(0, 0, 0, 1)');
    ctx.fillStyle = grad;
    ctx.beginPath();
    ctx.arc(0,0,r*1.02,0,Math.PI*2);
    ctx.fill();

    const outerR = r * 0.98;
    ctx.strokeStyle = 'rgba(0,180,255,0.35)';
    ctx.lineWidth = 1.5;
    ctx.beginPath();
    ctx.arc(0,0,outerR,0,Math.PI*2);
    ctx.stroke();

    const inRange = isInRange(centsSm);

    const ringBaseR = r * 0.75;
    ctx.strokeStyle = inRange ? 'rgba(0,220,255,0.7)' : 'rgba(255,80,80,0.6)';
    ctx.lineWidth = locked ? 3.4 : 2.4;
    ctx.shadowColor = inRange ? 'rgba(0,220,255,0.5)' : 'rgba(255,0,0,0.6)';
    ctx.shadowBlur  = locked ? 20 : 10;
    ctx.beginPath();
    ctx.arc(0,0,ringBaseR,0,Math.PI*2);
    ctx.stroke();
    ctx.shadowBlur = 0;

    const tickR1 = r*0.80;
    const tickR2 = r*0.92;
    for (let deg = -60; deg <= 60; deg += 5){
      const tickAng = BASE_ANG + (deg * Math.PI / 180);
      const strength = 1 - Math.min(1, Math.abs(deg) / 65);
      const alpha = 0.12 + 0.5 * strength;
      const isMajor = (deg % 10 === 0);

      ctx.strokeStyle = `rgba(${inRange ? '0,200,255' : '255,90,90'},${alpha})`;
      ctx.lineWidth = isMajor ? 2.0 : 1.0;
      ctx.beginPath();
      ctx.moveTo(Math.cos(tickAng) * tickR1, Math.sin(tickAng) * tickR1);
      ctx.lineTo(Math.cos(tickAng) * tickR2, Math.sin(tickAng) * tickR2);
      ctx.stroke();
    }

    const markR = r * 0.98;
    ctx.strokeStyle = inRange 
      ? 'rgba(0,255,255,0.9)' 
      : 'rgba(255,80,80,0.9)';
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.moveTo(Math.cos(BASE_ANG) * markR * 0.94, Math.sin(BASE_ANG) * markR * 0.94);
    ctx.lineTo(Math.cos(BASE_ANG) * markR, Math.sin(BASE_ANG) * markR);
    ctx.stroke();

    const MAX_STROBE_SEG = 72;
    const strobeR0 = r * 0.57;
    const strobeR1 = r * 0.83;
    const angNeedle12 = BASE_ANG + ang;
    const focusSigma = locked ? 0.23 : 0.35;
    const dashAng = (Math.PI * 2) / MAX_STROBE_SEG * 0.7;

    for (let i = 0; i < MAX_STROBE_SEG; i++){
      const phi = -Math.PI + (i + 0.5) * ((Math.PI * 2) / MAX_STROBE_SEG) + BASE_ANG;
      const d   = Math.atan2(Math.sin(phi - angNeedle12), Math.cos(phi - angNeedle12));
      const weight = Math.exp(-(d * d) / (2 * focusSigma * focusSigma));
      const a0 = phi - dashAng * 0.7;
      const a1 = phi + dashAng * 0.5;

      const baseAlpha = locked ? 0.18 : 0.10;
      const addAlpha  = locked ? 0.85 : 0.80;

      ctx.strokeStyle = inRange
        ? RGBA({r:0, g:136, b:255}, baseAlpha + addAlpha * weight)
        : RGBA({r:255, g:0, b:0}, 0.12 + 0.78 * weight);
      ctx.lineWidth = r * 0.055 * (0.6 + 0.4 * weight);

      ctx.beginPath();
      ctx.arc(0, 0, strobeR0, a0, a1);
      ctx.stroke();

      ctx.beginPath();
      ctx.arc(0, 0, strobeR1, a0, a1);
      ctx.stroke();
    }

    const needleLen  = r * 0.78;
    const needleBack = r * 0.18;
    const needleAng  = BASE_ANG + ang;

    const baseCol = inRange ? {r:0,g:220,b:255} : {r:255,g:110,b:110};

    const tipX  = Math.cos(needleAng) * needleLen;
    const tipY  = Math.sin(needleAng) * needleLen;
    const tailX = Math.cos(needleAng + Math.PI) * needleBack;
    const tailY = Math.sin(needleAng + Math.PI) * needleBack;

    ctx.shadowColor = RGBA(baseCol, locked ? 0.55 : 0.3);
    ctx.shadowBlur  = locked ? 22 : 14;
    ctx.lineCap = 'round';

    ctx.lineWidth = 4.5;
    ctx.strokeStyle = RGBA({r:0,g:0,b:0}, 0.9);
    ctx.beginPath();
    ctx.moveTo(tailX * 0.96, tailY * 0.96);
    ctx.lineTo(tipX * 1.01, tipY * 1.01);
    ctx.stroke();

    const gradNeedle = ctx.createLinearGradient(tailX, tailY, tipX, tipY);
    const headCol = inRange ? 'rgba(0,255,255,1)' : 'rgba(255,160,160,1)';
    gradNeedle.addColorStop(0.0, 'rgba(0,0,0,0.0)');
    gradNeedle.addColorStop(0.25,'rgba(0,180,255,0.65)');
    gradNeedle.addColorStop(0.7, headCol);
    gradNeedle.addColorStop(1.0,'rgba(255,255,255,0.9)');

    ctx.lineWidth = 3.0;
    ctx.strokeStyle = gradNeedle;
    ctx.beginPath();
    ctx.moveTo(tailX, tailY);
    ctx.lineTo(tipX, tipY);
    ctx.stroke();
    ctx.shadowBlur = 0;

    ctx.fillStyle = 'rgba(0,0,0,0.9)';
    ctx.beginPath();
    ctx.arc(0, 0, r * 0.07, 0, Math.PI * 2);
    ctx.fill();

    const innerGrad = ctx.createRadialGradient(0,0,0,0,0,r*0.32);
    innerGrad.addColorStop(0.0, 'rgba(0,0,0,1)');
    innerGrad.addColorStop(0.5, 'rgba(0,40,80,1)');
    innerGrad.addColorStop(1.0, 'rgba(0,0,0,1)');
    ctx.fillStyle = innerGrad;
    ctx.beginPath();
    ctx.arc(0, 0, r * 0.38, 0, Math.PI * 2);
    ctx.fill();

    const noteToShow = noteL || '--';
    ctx.fillStyle = '#e8f7ff';
    ctx.font = `${r*0.22}px "SF Mono", ui-monospace, Menlo, Consolas, monospace`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(noteToShow, 0, r * 0.10);

    ctx.fillStyle = 'rgba(120,200,255,0.9)';
    ctx.font = `${r*0.11}px "SF Mono", ui-monospace`;
    ctx.fillText(`${freq.toFixed(2)} Hz`, 0, -r * 0.10);

    ctx.restore();

    requestAnimationFrame(draw);
  }

  requestAnimationFrame(draw);
})();
</script>

<!-- ===== JS Tuner (クロマチック＋Tuningスナップ) ===== -->
<script>
(function(){
  'use strict';

  const NOTE_NAMES = ['C','C#','D','D#','E','F','F#','G','G#','A','A#','B'];
  const A4_REF = 440.0;
  const SHOW_DEBUG = false; // trueにするとRMSなども表示

  function freqToNoteInfo(freq) {
    if (!freq || !Number.isFinite(freq) || freq <= 0) return null;
    const midi = Math.round(69 + 12 * Math.log2(freq / A4_REF));
    const noteName = NOTE_NAMES[(midi % 12 + 12) % 12];
    const octave = Math.floor(midi / 12) -1;
    const target = A4_REF * Math.pow(2, (midi - 69) / 12);
    const cents = 1200 * Math.log2(freq / target);
    return { note: noteName, oct: octave, cents, target };
  }

  // Tuning プリセット
  const TUNINGS = {
    chromatic: {
      id: 'chromatic',
      label: 'Chromatic',
      strings: null
    },
    gtr_std: {
      id: 'gtr_std',
      label: 'Guitar - Standard',
      strings: [
        { name: 'E2', freq: 82.41, string: 6 },
        { name: 'A2', freq: 110.00, string: 5 },
        { name: 'D3', freq: 146.83, string: 4 },
        { name: 'G3', freq: 196.00, string: 3 },
        { name: 'B3', freq: 246.94, string: 2 },
        { name: 'E4', freq: 329.63, string: 1 }
      ]
    },
    gtr_drop_csharp: {
      id: 'gtr_drop_csharp',
      label: 'Guitar - Drop C#',
      strings: [
        { name: 'C#2', freq: 69.30, string: 6 },
        { name: 'G#2', freq: 103.83, string: 5 },
        { name: 'C#3', freq: 138.59, string: 4 },
        { name: 'F#3', freq: 185.00, string: 3 },
        { name: 'A#3', freq: 233.08, string: 2 },
        { name: 'C#4', freq: 277.18, string: 1 }
      ]
    }
  };

  // rawFreq から、f / f2 / f4 を試して最も近い弦にスナップ
  function snapToTuning(rawFreq, tuning){
    if (!tuning || !tuning.strings || !rawFreq) return null;

    const candidates = [rawFreq, rawFreq / 2, rawFreq / 4];
    let best = null;
    let bestDiff = Infinity;

    for (const cFreq of candidates) {
      if (!cFreq || cFreq < 40 || cFreq > 1000) continue;
      for (const s of tuning.strings) {
        const diff = Math.abs(cFreq - s.freq);
        if (diff < bestDiff) {
          bestDiff = diff;
          best = {
            string: s.string,
            name: s.name,
            targetFreq: s.freq,
            fundFreq: cFreq
          };
        }
      }
    }

    if (!best) return null;

    // ±1.5半音より外れてたらノイズ扱い
    const maxSemi  = 1.5;
    const maxRatio = Math.pow(2, maxSemi / 12);
    if (best.fundFreq < best.targetFreq / maxRatio ||
        best.fundFreq > best.targetFreq * maxRatio) {
      return null;
    }

    best.cents = 1200 * Math.log2(best.fundFreq / best.targetFreq);
    return best;
  }

  let audioCtx    = null;
  let sourceNode  = null;
  let gainNode    = null;
  let analyser    = null;
  let running     = false;
  let confEMA     = 0;
  let lastGood    = null;
  let currentTuningId = 'gtr_drop_csharp';

  const startBtn     = document.getElementById('startBtn');
  const statusEl     = document.getElementById('status');
  const metricsEl    = document.getElementById('metrics');
  const tuningSelect = document.getElementById('tuningSelect');

  if (tuningSelect) {
    currentTuningId = tuningSelect.value || 'gtr_drop_csharp';
    tuningSelect.value = currentTuningId;
    tuningSelect.addEventListener('change', () => {
      currentTuningId = tuningSelect.value || 'chromatic';
    });
  }

  function autoCorrelate(buf, sampleRate) {
    const size = buf.length;
    let rms = 0;
    for (let i = 0; i < size; i++) {
      const v = buf[i];
      rms += v * v;
    }
    rms = Math.sqrt(rms / size);

    // 小さすぎる音は切る（フェンダー寄り）
    if (rms < 0.0020) {
      return { freq: null, rms, corr: 0 };
    }

    const MIN_FREQ = 40;
    const MAX_FREQ = 1200;

    const minLag = Math.floor(sampleRate / MAX_FREQ);
    const maxLag = Math.min(Math.floor(sampleRate / MIN_FREQ), Math.floor(size / 2));

    let bestOffset = -1;
    let bestCorrelation = 0;
    let foundGood = false;
    let lastCorrelation = 1;

    for (let lag = minLag; lag <= maxLag; lag++) {
      let correlation = 0;
      const corrLen = size - lag;
      for (let i = 0; i < corrLen; i++) {
        const diff = buf[i] - buf[i + lag];
        correlation += Math.abs(diff);
      }
      correlation = 1 - (correlation / corrLen);

      if (correlation > 0.75 && correlation > lastCorrelation) {
        foundGood = true;
      } else if (foundGood && correlation < lastCorrelation) {
        break;
      }

      if (correlation > bestCorrelation) {
        bestCorrelation = correlation;
        bestOffset = lag;
      }

      lastCorrelation = correlation;
    }

    if (bestOffset <= 0 || bestCorrelation < 0.1) {
      return { freq: null, rms, corr: 0 };
    }

    const freq = sampleRate / bestOffset;
    if (freq < MIN_FREQ || freq > MAX_FREQ) {
      return { freq: null, rms, corr: 0 };
    }

    return { freq, rms, corr: bestCorrelation };
  }

  function updateLoop() {
    if (!running || !analyser) return;

    const bufferLen = analyser.fftSize;
    const timeData = new Float32Array(bufferLen);
    analyser.getFloatTimeDomainData(timeData);

    const ac = autoCorrelate(timeData, audioCtx.sampleRate);
    const rawFreq = ac.freq;
    const rms = ac.rms || 0;
    const db  = rms > 0 ? 20 * Math.log10(rms) : -120;

    const tuning = TUNINGS[currentTuningId] || TUNINGS.chromatic;

    let chromFreq   = null;
    let chromNote   = '--';
    let chromCents  = 0;

    if (rawFreq && rawFreq > 20 && rawFreq < 5000) {
      const info = freqToNoteInfo(rawFreq);
      if (info) {
        chromFreq  = rawFreq;
        chromNote  = `${info.note}${info.oct}`;
        chromCents = info.cents;
      }
    }

    let finalFreq   = chromFreq;
    let finalNote   = chromNote;
    let finalCents  = chromCents;

    if (rawFreq && tuning.strings) {
      const snapped = snapToTuning(rawFreq, tuning);
      if (snapped) {
        finalFreq   = snapped.fundFreq;
        finalNote   = snapped.name;
        finalCents  = snapped.cents;
      }
    }

    if (finalFreq && finalNote !== '--') {
      lastGood = {
        freq: finalFreq,
        note: finalNote,
        cents: finalCents,
        time: performance.now()
      };
    } else if (!finalFreq && lastGood && (performance.now() - lastGood.time) < 300) {
      // 音が途切れても 300ms は最後の値を保持
      finalFreq  = lastGood.freq;
      finalNote  = lastGood.note;
      finalCents = lastGood.cents;
    }

    let instConf = 0;
    if (finalFreq) {
      const centsNorm = Math.min(50, Math.abs(finalCents));
      const centsScore = 1 - (centsNorm / 50);
      const dbClamp = Math.max(-80, Math.min(-10, db));
      const dbNorm = (dbClamp + 80) / 70;
      instConf = Math.max(0, Math.min(1, centsScore * 0.7 + dbNorm * 0.3));
    }

    const alpha = 0.15;
    confEMA = (1 - alpha) * confEMA + alpha * instConf;
    if (!isFinite(confEMA)) confEMA = 0;
    window.dpConfEMA = confEMA;

    if (finalFreq) {
      window.setTunerState(finalFreq, finalNote, finalCents);
    }

    let text = '';
    if (SHOW_DEBUG) {
      text +=
`RMS:   ${rms.toFixed(5)}
dBFS:  ${db.toFixed(1)}
Conf:  ${confEMA.toFixed(2)}\n`;
    }
    text +=
`Freq:  ${finalFreq ? finalFreq.toFixed(2) + " Hz" : "--"}
Note:  ${finalNote}
Cents: ${finalFreq ? finalCents.toFixed(2) + " cents" : "--"}`;

    if (metricsEl) {
      metricsEl.textContent = text;
    }

    requestAnimationFrame(updateLoop);
  }

  async function initTuner() {
    if (running) return;

    startBtn.disabled = true;
    statusEl.textContent = 'Initializing…';

    try {
      statusEl.textContent = 'Requesting mic access…';

      const legacyGetUserMedia =
        navigator.getUserMedia ||
        navigator.webkitGetUserMedia ||
        navigator.mozGetUserMedia ||
        navigator.msGetUserMedia;

      const getUserMedia = (constraints) => {
        if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
          return navigator.mediaDevices.getUserMedia(constraints);
        } else if (legacyGetUserMedia) {
          return new Promise((resolve, reject) => {
            legacyGetUserMedia.call(navigator, constraints, resolve, reject);
          });
        } else {
          return null;
        }
      };

      const isMobile = /Android|webOS|iPhone|iPad|iPod/i.test(navigator.userAgent);

      const gUM = getUserMedia({
        audio: {
          channelCount: 1,
          echoCancellation: false,
          noiseSuppression: false,
          autoGainControl: false
        }
      });

      if (!gUM) {
        throw new Error('This browser cannot use the microphone on this device.');
      }

      const stream = await gUM;

      const AudioContextClass = window.AudioContext || window.webkitAudioContext;
      audioCtx = new AudioContextClass();

      if (audioCtx.state === 'suspended') {
        await audioCtx.resume();
      }

      sourceNode = audioCtx.createMediaStreamSource(stream);

      gainNode = new GainNode(audioCtx);
      gainNode.gain.value = isMobile ? 3.0 : 2.5;

      analyser = audioCtx.createAnalyser();
      analyser.fftSize = isMobile ? 2048 : 4096;
      analyser.smoothingTimeConstant = 0;

      sourceNode.connect(gainNode);
      gainNode.connect(analyser);

      running = true;
      statusEl.textContent = isMobile
        ? 'Tuning... (hold phone near the guitar)'
        : 'Tuning...';

      requestAnimationFrame(updateLoop);

    } catch (err) {
      console.error('[ΔPhase] initTuner error:', err);
      statusEl.textContent = 'Error: ' + err.message + '\nHTTPS and microphone permission are required.';
      startBtn.disabled = false;
    }
  }

  if (startBtn) {
    startBtn.addEventListener('click', () => {
      initTuner();
    });
  }

})();
</script>

</body>
</html>
