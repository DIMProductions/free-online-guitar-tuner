<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Free Online Guitar & Instrument Tuner</title>
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <meta name="description" content="Free online tuner that runs in your browser. Supports guitar, bass, and other instruments using your device microphone. Real-time circular HUD with note, frequency (Hz), and cent deviation.">

  <style>
  * {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
  }

  body {
    height: 100vh;
    background: radial-gradient(ellipse at 30% 30%, #000 0%, #000 50%, #000 100%);
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    font-family: ui-monospace, "SF Mono", Menlo, Consolas, monospace;
    color: #e8f7ff;
  }

  .meter-pane,
  .circle-meter-container {
    position: relative;
    width: min(70vmin, 520px);
    aspect-ratio: 1;
  }

  .hud-canvas {
    position: absolute;
    inset: 0;
    width: 100%;
    height: 100%;
    display: block;
    filter: drop-shadow(0 0 18px rgba(43,108,255,.45));
    z-index: 1;
  }

  .hud-ring {
    position: absolute;
    inset: 0;
    display: grid;
    place-items: center;
    pointer-events: none;
    filter: drop-shadow(0 0 10px rgba(0,255,255,.12));
    z-index: 0;
  }

  .hud-ring > svg {
    width: 100%;
    height: 100%;
    display: block;
    transform-origin: 50% 50%;
    transform: scale(0.98);
  }

  .control-strip {
    width: 100%;
    max-width: 520px;
    margin-top: 20px;
    padding: 10px 12px 16px;
    border-radius: 999px;
    background:
      radial-gradient(circle at 0 0, rgba(0,180,255,0.12) 0, transparent 45%),
      radial-gradient(circle at 100% 100%, rgba(255,100,180,0.08) 0, transparent 50%),
      linear-gradient(135deg, #020712 0%, #050b16 50%, #020509 100%);
    border: 1px solid rgba(0,255,255,0.2);
    box-shadow:
      0 0 0 1px rgba(0,0,0,0.9),
      0 16px 40px rgba(0,0,0,0.85);
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 6px;
  }

  #startBtn {
    padding: 8px 18px;
    border-radius: 999px;
    border: 1px solid rgba(0,255,255,0.7);
    background:
      radial-gradient(circle at 30% 0%, #0b2f4a 0, #021017 42%, #000 100%);
    color: #e8f7ff;
    font-size: 13px;
    letter-spacing: 0.09em;
    text-transform: uppercase;
    text-shadow: 0 0 6px rgba(0,255,255,0.7);
    box-shadow:
      0 0 12px rgba(0,255,255,0.6),
      0 0 36px rgba(0,140,255,0.35);
    cursor: pointer;
    display: inline-flex;
    align-items: center;
    gap: 6px;
  }

  #startBtn:hover:not(:disabled) {
    box-shadow:
      0 0 16px rgba(0,255,255,0.85),
      0 0 42px rgba(0,140,255,0.5);
    transform: translateY(-0.5px);
  }

  #startBtn:disabled {
    opacity: 0.45;
    cursor: not-allowed;
    transform: none;
    box-shadow: none;
  }

  #status {
    font-size: 14px;
    color: #79bcd1;
    text-align: center;
  }

  #metrics {
    margin-top: 12px;
    font-size: 11px;
    color: #5a8a9a;
    text-align: center;
    font-family: ui-monospace, monospace;
    white-space: pre;
  }

  /* ==== スマホ用レイアウト調整 ==== */
  @media (max-width: 600px) {
    body {
      height: 100vh;
      padding: 12px 8px;
      justify-content: flex-start;
      gap: 16px;
    }

    .meter-pane,
    .circle-meter-container {
      width: 100%;
      max-width: 420px;
    }

    .control-strip {
      max-width: 420px;
      margin-top: 14px;
      padding: 8px 12px 12px;
      border-radius: 24px;
      gap: 4px;
    }

    #startBtn {
      width: 100%;
      justify-content: center;
      font-size: 12px;
      padding: 10px 12px;
    }

    #status {
      font-size: 12px;
    }

    #metrics {
      font-size: 10px;
    }
  }
  </style>
</head>
<body>

<div class="meter-pane">
  <div class="circle-meter-container">
    <canvas class="hud-canvas" id="hudCanvas"></canvas>

    <div class="hud-ring">
      <!-- 必要ならここにSVGリングを後で入れる -->
    </div>
  </div>
</div>

<div class="control-strip">
  <button id="startBtn">TAP TO START TUNER</button>
  <div id="status">Idle</div>
  <div id="metrics"></div>
</div>

<!-- ===== Circle HUD + レンズ描画 ===== -->
<script>
(function(){
  'use strict';

  const NOTE = ['C','C#','D','D#','E','F','F#','G','G#','A','A#','B'];
  const A4 = 440.0;
  const MAX_CENTS = 50;
  const MAX_ANG   = 60 * Math.PI / 180;
  const BASE_ANG  = -Math.PI / 2;

  const canvas = document.getElementById('hudCanvas');
  if (!canvas) return;

  const DPR = Math.min(1.75, window.devicePixelRatio || 1);
  const ctx = canvas.getContext('2d');

  // 裏キャンバス
  const backCanvas = document.createElement('canvas');
  const backCtx = backCanvas.getContext('2d');

  function fit(){
    const r = canvas.getBoundingClientRect();
    const wPx = r.width  * DPR;
    const hPx = r.height * DPR;

    canvas.width  = wPx;
    canvas.height = hPx;

    backCanvas.width  = wPx;
    backCanvas.height = hPx;

    backCtx.setTransform(DPR, 0, 0, DPR, 0, 0);
    ctx.setTransform(1, 0, 0, 1, 0, 0);
  }
  fit();
  window.addEventListener('resize', fit);

  function clamp(v, lo, hi){ return Math.max(lo, Math.min(hi, v)); }
  function lowpass(prev, next, dt, hz){
    const a = 1 - Math.exp(-dt * hz * 2 * Math.PI);
    return prev + (next - prev) * clamp(a, 0, 1);
  }
  function isInRange(c){ return Math.abs(c) <= 5; }
  function RGBA(c, a){ return `rgba(${c.r},${c.g},${c.b},${a})`; }

  function analyze(f, a4ref){
    const midi = Math.round(69 + 12 * Math.log2(f / a4ref));
    const note = NOTE[(midi % 12 + 12) % 12];
    const oct  = Math.floor(midi / 12) -1;
    const target = a4ref * Math.pow(2, (midi - 69) / 12);
    const cents  = 1200 * Math.log2(f / target);
    return { note, oct, target, cents, adjCents: cents };
  }

  function needleAngleFromCents(c){
    return clamp((c / MAX_CENTS) * MAX_ANG, -MAX_ANG, MAX_ANG);
  }

  window.tunerFreq = 440;
  window.setTunerFrequency = function(f){
    if (!Number.isFinite(f) || f <= 0) return;
    window.tunerFreq = f;
  };
  window.dpConfEMA = 0;
  window.dpLocked  = false;

  function getFreq() { return window.tunerFreq || 440; }

  let tPrev = performance.now();
  let centsSm = 0;

  const centsSamples = [];
  const MAX_SAMPLES = 9;

  function pushCentsSample(c, conf){
    if (conf < 0.25) {
      centsSamples.length = 0;
      return;
    }
    centsSamples.push(c);
    if (centsSamples.length > MAX_SAMPLES) {
      centsSamples.shift();
    }
  }

  function getSmoothedCents(){
    if (centsSamples.length === 0) return 0;
    let sum = 0;
    for (let i = 0; i < centsSamples.length; i++){
      sum += centsSamples[i];
    }
    return sum / centsSamples.length;
  }

  let lockState = "idle";
  let lockEnterTime = 0;
  let lockLastGoodTime = 0;

  function updateLock(nowMs, baseLock, conf){
    const ok = baseLock && conf >= 0.22;
    if (ok) lockLastGoodTime = nowMs;

    if (lockState === "idle") {
      if (ok) {
        lockState = "locking";
        lockEnterTime = nowMs;
      }
    } else if (lockState === "locking") {
      if (!ok) {
        lockState = "idle";
      } else if (nowMs - lockEnterTime > 50) {
        lockState = "locked";
      }
    } else if (lockState === "locked") {
      if (nowMs - lockLastGoodTime > 500) {
        lockState = "idle";
      }
    }
    return lockState === "locked";
  }

  function draw(){
    const tNow = performance.now();
    const dt   = (tNow - tPrev) / 1000;
    tPrev = tNow;

    const freq = getFreq();
    const info = analyze(freq, A4);
    const conf = clamp(window.dpConfEMA || 0, 0, 1);

    const rawCents = clamp(info.adjCents, -MAX_CENTS, MAX_CENTS);
    pushCentsSample(rawCents, conf);
    const smoothCents = getSmoothedCents();

    centsSm = lowpass(centsSm, smoothCents, dt, 4);

    const ang = needleAngleFromCents(centsSm);
    const baseLock = Math.abs(centsSm) <= 10;
    const locked = updateLock(tNow, baseLock, conf);
    window.dpLocked = locked;

    const wCss = canvas.width  / DPR;
    const hCss = canvas.height / DPR;
    const cx   = wCss * 0.5;
    const cy   = hCss * 0.5;
    const r    = Math.min(wCss, hCss) * 0.46;

    // ===== 1) 裏キャンバスにHUD描画 =====
    backCtx.clearRect(0,0,wCss,hCss);

    backCtx.save();
    backCtx.translate(cx, cy);

    // ===== フォトリアルなガラス球 =====
    
    // 1. 外側の柔らかいグロー（環境光の拡散）
    const outerGlow = backCtx.createRadialGradient(0, 0, r*0.7, 0, 0, r*1.3);
    outerGlow.addColorStop(0.0, 'rgba(180, 200, 220, 0.02)');
    outerGlow.addColorStop(0.5, 'rgba(120, 150, 180, 0.04)');
    outerGlow.addColorStop(0.8, 'rgba(60, 80, 100, 0.03)');
    outerGlow.addColorStop(1.0, 'rgba(0, 0, 0, 0)');
    backCtx.fillStyle = outerGlow;
    backCtx.beginPath();
    backCtx.arc(0, 0, r*1.3, 0, Math.PI*2);
    backCtx.fill();

    // 2. ガラス本体（屈折を考慮した透明感）
    const glassBody = backCtx.createRadialGradient(-r*0.15, -r*0.15, r*0.1, 0, 0, r);
    glassBody.addColorStop(0.0, 'rgba(60, 70, 85, 0.4)');      // 中心は明るめ
    glassBody.addColorStop(0.3, 'rgba(40, 50, 65, 0.6)');      
    glassBody.addColorStop(0.6, 'rgba(20, 30, 45, 0.8)');      
    glassBody.addColorStop(0.85, 'rgba(10, 15, 25, 0.95)');    
    glassBody.addColorStop(1.0, 'rgba(5, 8, 15, 1)');          // エッジは濃く
    backCtx.fillStyle = glassBody;
    backCtx.beginPath();
    backCtx.arc(0, 0, r, 0, Math.PI*2);
    backCtx.fill();

    // 3. メインハイライト（上部左からの光源）
    const mainHighlight = backCtx.createRadialGradient(-r*0.3, -r*0.4, 0, -r*0.3, -r*0.4, r*0.55);
    mainHighlight.addColorStop(0.0, 'rgba(255, 255, 255, 0.6)');
    mainHighlight.addColorStop(0.15, 'rgba(240, 250, 255, 0.4)');
    mainHighlight.addColorStop(0.35, 'rgba(200, 220, 240, 0.2)');
    mainHighlight.addColorStop(0.6, 'rgba(150, 180, 210, 0.1)');
    mainHighlight.addColorStop(1.0, 'rgba(0, 0, 0, 0)');
    backCtx.fillStyle = mainHighlight;
    backCtx.beginPath();
    backCtx.arc(0, 0, r, 0, Math.PI*2);
    backCtx.fill();

    // 4. サブハイライト（右上の環境反射）
    const subHighlight = backCtx.createRadialGradient(r*0.25, -r*0.35, 0, r*0.25, -r*0.35, r*0.35);
    subHighlight.addColorStop(0.0, 'rgba(220, 235, 250, 0.15)');
    subHighlight.addColorStop(0.4, 'rgba(180, 200, 220, 0.08)');
    subHighlight.addColorStop(1.0, 'rgba(0, 0, 0, 0)');
    backCtx.fillStyle = subHighlight;
    backCtx.beginPath();
    backCtx.arc(0, 0, r, 0, Math.PI*2);
    backCtx.fill();

    // 5. 下部の反射光（床からの反射）
    const bottomReflect = backCtx.createRadialGradient(0, r*0.5, r*0.05, 0, r*0.5, r*0.4);
    bottomReflect.addColorStop(0.0, 'rgba(180, 200, 220, 0.12)');
    bottomReflect.addColorStop(0.5, 'rgba(140, 160, 180, 0.06)');
    bottomReflect.addColorStop(1.0, 'rgba(0, 0, 0, 0)');
    backCtx.fillStyle = bottomReflect;
    backCtx.beginPath();
    backCtx.arc(0, 0, r, 0, Math.PI*2);
    backCtx.fill();

    // 6. エッジの屈折リング（ガラスの厚み表現）
    const edgeRefract = backCtx.createRadialGradient(0, 0, r*0.92, 0, 0, r);
    edgeRefract.addColorStop(0.0, 'rgba(0, 0, 0, 0)');
    edgeRefract.addColorStop(0.7, 'rgba(180, 200, 220, 0.15)');
    edgeRefract.addColorStop(0.85, 'rgba(220, 235, 250, 0.3)');
    edgeRefract.addColorStop(0.95, 'rgba(200, 215, 230, 0.2)');
    edgeRefract.addColorStop(1.0, 'rgba(0, 0, 0, 0)');
    backCtx.fillStyle = edgeRefract;
    backCtx.beginPath();
    backCtx.arc(0, 0, r, 0, Math.PI*2);
    backCtx.fill();

    // 7. 外側リムライト（ガラスの縁）
    backCtx.strokeStyle = 'rgba(240, 250, 255, 0.4)';
    backCtx.lineWidth = 2.0;
    backCtx.beginPath();
    backCtx.arc(0, 0, r*0.995, 0, Math.PI*2);
    backCtx.stroke();

    backCtx.strokeStyle = 'rgba(200, 220, 240, 0.2)';
    backCtx.lineWidth = 1.0;
    backCtx.beginPath();
    backCtx.arc(0, 0, r*0.988, 0, Math.PI*2);
    backCtx.stroke();

    // 外枠
    const outerR = r * 0.98;
    backCtx.strokeStyle = 'rgba(0,180,255,0.35)';
    backCtx.lineWidth = 1.5;
    backCtx.beginPath();
    backCtx.arc(0,0,outerR,0,Math.PI*2);
    backCtx.stroke();

    const inRange = isInRange(centsSm);

    // ロックリング
    const ringBaseR = r * 0.75;
    backCtx.strokeStyle = inRange ? 'rgba(0,220,255,0.7)' : 'rgba(255,80,80,0.6)';
    backCtx.lineWidth = locked ? 3.4 : 2.4;
    backCtx.shadowColor = inRange ? 'rgba(0,220,255,0.5)' : 'rgba(255,0,0,0.6)';
    backCtx.shadowBlur  = locked ? 20 : 10;
    backCtx.beginPath();
    backCtx.arc(0,0,ringBaseR,0,Math.PI*2);
    backCtx.stroke();
    backCtx.shadowBlur = 0;

    // 目盛り
    const tickR1 = r*0.80;
    const tickR2 = r*0.92;
    for (let deg = -60; deg <= 60; deg += 5){
      const tickAng = BASE_ANG + (deg * Math.PI / 180);
      const strength = 1 - Math.min(1, Math.abs(deg) / 65);
      const alpha = 0.12 + 0.5 * strength;
      const isMajor = (deg % 10 === 0);

      backCtx.strokeStyle = `rgba(${inRange ? '0,200,255' : '255,90,90'},${alpha})`;
      backCtx.lineWidth = isMajor ? 2.0 : 1.0;
      backCtx.beginPath();
      backCtx.moveTo(Math.cos(tickAng) * tickR1, Math.sin(tickAng) * tickR1);
      backCtx.lineTo(Math.cos(tickAng) * tickR2, Math.sin(tickAng) * tickR2);
      backCtx.stroke();
    }

    // 中央マーク
    const markR = r * 0.98;
    backCtx.strokeStyle = inRange 
      ? 'rgba(0,255,255,0.9)' 
      : 'rgba(255,80,80,0.9)';
    backCtx.lineWidth = 3;
    backCtx.beginPath();
    backCtx.moveTo(Math.cos(BASE_ANG) * markR * 0.94, Math.sin(BASE_ANG) * markR * 0.94);
    backCtx.lineTo(Math.cos(BASE_ANG) * markR,        Math.sin(BASE_ANG) * markR);
    backCtx.stroke();

    // ストロボリング
    const strobeR0 = r * 0.57;
    const strobeR1 = r * 0.83;
    const strobeSegs = 72;
    const angNeedle12 = BASE_ANG + ang;
    const focusSigma = locked ? 0.23 : 0.35;
    const dashAng = (Math.PI * 2) / strobeSegs * 0.7;

    for (let i = 0; i < strobeSegs; i++){
      const phi = -Math.PI + (i + 0.5) * ((Math.PI * 2) / strobeSegs) + BASE_ANG;
      const d   = Math.atan2(Math.sin(phi - angNeedle12), Math.cos(phi - angNeedle12));
      const weight = Math.exp(-(d * d) / (2 * focusSigma * focusSigma));
      const a0 = phi - dashAng * 0.7;
      const a1 = phi + dashAng * 0.5;

      const baseAlpha = locked ? 0.18 : 0.10;
      const addAlpha  = locked ? 0.85 : 0.80;

      backCtx.strokeStyle = inRange
        ? RGBA({r:0, g:136, b:255}, baseAlpha + addAlpha * weight)
        : RGBA({r:255, g:0, b:0}, 0.12 + 0.78 * weight);
      backCtx.lineWidth = r * 0.055 * (0.6 + 0.4 * weight);

      backCtx.beginPath();
      backCtx.arc(0, 0, strobeR0, a0, a1);
      backCtx.stroke();

      backCtx.beginPath();
      backCtx.arc(0, 0, strobeR1, a0, a1);
      backCtx.stroke();
    }

    // 針
    const needleLen  = r * 0.78;
    const needleBack = r * 0.18;
    const needleAng  = BASE_ANG + ang;

    const baseCol = inRange ? {r:0,g:220,b:255} : {r:255,g:110,b:110};

    const tipX  = Math.cos(needleAng) * needleLen;
    const tipY  = Math.sin(needleAng) * needleLen;
    const tailX = Math.cos(needleAng + Math.PI) * needleBack;
    const tailY = Math.sin(needleAng + Math.PI) * needleBack;

    backCtx.shadowColor = RGBA(baseCol, locked ? 0.55 : 0.3);
    backCtx.shadowBlur  = locked ? 22 : 14;
    backCtx.lineCap = 'round';

    backCtx.lineWidth = 4.5;
    backCtx.strokeStyle = RGBA({r:0,g:0,b:0}, 0.9);
    backCtx.beginPath();
    backCtx.moveTo(tailX * 0.96, tailY * 0.96);
    backCtx.lineTo(tipX * 1.01, tipY * 1.01);
    backCtx.stroke();

    const gradNeedle = backCtx.createLinearGradient(tailX, tailY, tipX, tipY);
    const headCol = inRange ? 'rgba(0,255,255,1)' : 'rgba(255,160,160,1)';
    gradNeedle.addColorStop(0.0, 'rgba(0,0,0,0.0)');
    gradNeedle.addColorStop(0.25,'rgba(0,180,255,0.65)');
    gradNeedle.addColorStop(0.7, headCol);
    gradNeedle.addColorStop(1.0,'rgba(255,255,255,0.9)');

    backCtx.lineWidth = 3.0;
    backCtx.strokeStyle = gradNeedle;
    backCtx.beginPath();
    backCtx.moveTo(tailX, tailY);
    backCtx.lineTo(tipX, tipY);
    backCtx.stroke();
    backCtx.shadowBlur = 0;

    // 中央エリア（ガラス球内部の窪み）
    const innerGlass = backCtx.createRadialGradient(-r*0.05, -r*0.08, 0, 0, 0, r*0.38);
    innerGlass.addColorStop(0.0, 'rgba(50, 60, 75, 0.7)');
    innerGlass.addColorStop(0.3, 'rgba(30, 40, 55, 0.85)');
    innerGlass.addColorStop(0.7, 'rgba(15, 20, 30, 0.95)');
    innerGlass.addColorStop(1.0, 'rgba(5, 8, 12, 1)');
    backCtx.fillStyle = innerGlass;
    backCtx.beginPath();
    backCtx.arc(0, 0, r * 0.38, 0, Math.PI * 2);
    backCtx.fill();

    // 中央のハイライト
    const innerHighlight = backCtx.createRadialGradient(-r*0.1, -r*0.15, 0, -r*0.1, -r*0.15, r*0.25);
    innerHighlight.addColorStop(0.0, 'rgba(255, 255, 255, 0.2)');
    innerHighlight.addColorStop(0.4, 'rgba(200, 220, 240, 0.1)');
    innerHighlight.addColorStop(1.0, 'rgba(0, 0, 0, 0)');
    backCtx.fillStyle = innerHighlight;
    backCtx.beginPath();
    backCtx.arc(0, 0, r * 0.38, 0, Math.PI * 2);
    backCtx.fill();

    // 中央ピン（ガラス質感）
    const pinGlass = backCtx.createRadialGradient(-r*0.015, -r*0.02, 0, 0, 0, r*0.07);
    pinGlass.addColorStop(0.0, 'rgba(80, 90, 105, 0.8)');
    pinGlass.addColorStop(0.5, 'rgba(40, 50, 65, 0.9)');
    pinGlass.addColorStop(1.0, 'rgba(20, 25, 35, 1)');
    backCtx.fillStyle = pinGlass;
    backCtx.beginPath();
    backCtx.arc(0, 0, r * 0.07, 0, Math.PI * 2);
    backCtx.fill();

    // ピンのハイライト
    const pinHighlight = backCtx.createRadialGradient(-r*0.025, -r*0.035, 0, 0, 0, r*0.07);
    pinHighlight.addColorStop(0.0, 'rgba(255, 255, 255, 0.5)');
    pinHighlight.addColorStop(0.5, 'rgba(220, 235, 250, 0.2)');
    pinHighlight.addColorStop(1.0, 'rgba(0, 0, 0, 0)');
    backCtx.fillStyle = pinHighlight;
    backCtx.beginPath();
    backCtx.arc(0, 0, r * 0.07, 0, Math.PI * 2);
    backCtx.fill();

    // テキスト
    backCtx.fillStyle = '#e8f7ff';
    backCtx.font = `${r*0.22}px "SF Mono", ui-monospace, Menlo, Consolas, monospace`;
    backCtx.textAlign = 'center';
    backCtx.textBaseline = 'middle';
    backCtx.fillText(`${info.note}${info.oct}`, 0, r * 0.10);

    backCtx.fillStyle = 'rgba(120,200,255,0.9)';
    backCtx.font = `${r*0.11}px "SF Mono", ui-monospace`;
    backCtx.fillText(`${freq.toFixed(2)} Hz`, 0, -r * 0.10);

    backCtx.restore();

    // ===== 2) 表キャンバスに通常HUD =====
    ctx.clearRect(0,0,canvas.width,canvas.height);
    ctx.drawImage(backCanvas, 0, 0);

    // ===== 3) レンズ効果 =====
    const cxPx = cx * DPR;
    const cyPx = cy * DPR;
    const lensR   = r * 0.95;
    const lensRPx = lensR * DPR;
    const magnify = 1.06;

    // 拡大レンズ
    ctx.save();
    ctx.beginPath();
    ctx.arc(cxPx, cyPx, lensRPx, 0, Math.PI*2);
    ctx.clip();

    ctx.translate(cxPx, cyPx);
    ctx.scale(magnify, magnify);
    ctx.translate(-cxPx, -cyPx);

    ctx.drawImage(backCanvas, 0, 0);
    ctx.restore();

    // ガラスシェーディング
    ctx.save();
    ctx.beginPath();
    ctx.arc(cxPx, cyPx, lensRPx, 0, Math.PI*2);
    ctx.clip();

    let g2 = ctx.createRadialGradient(
      cxPx - lensRPx*0.32, cyPx - lensRPx*0.32, lensRPx*0.08,
      cxPx,                cyPx,               lensRPx
    );
    g2.addColorStop(0.0, 'rgba(255,255,255,0.32)');
    g2.addColorStop(0.25,'rgba(255,255,255,0.08)');
    g2.addColorStop(0.65,'rgba(0,0,0,0.24)');
    g2.addColorStop(1.0, 'rgba(0,0,0,0.55)');

    ctx.fillStyle = g2;
    ctx.fillRect(cxPx - lensRPx, cyPx - lensRPx, lensRPx*2, lensRPx*2);

    // 下側のうっすら反射光
    ctx.globalCompositeOperation = 'screen';
    ctx.fillStyle = 'rgba(255,255,255,0.12)';
    ctx.beginPath();
    ctx.ellipse(
      cxPx,
      cyPx + lensRPx*0.28,
      lensRPx*0.45,
      lensRPx*0.23,
      0,
      0,
      Math.PI*2
    );
    ctx.fill();

    ctx.restore();

    // 縁
    ctx.save();
    ctx.lineWidth = 2 * DPR;
    ctx.strokeStyle = 'rgba(255,255,255,0.9)';
    ctx.beginPath();
    ctx.arc(cxPx, cyPx, lensRPx - DPR, 0, Math.PI*2);
    ctx.stroke();

    // 白ハイライト：もっと端の方 & 薄め
    ctx.fillStyle = 'rgba(255,255,255,0.35)';
    ctx.beginPath();
    ctx.ellipse(
      cxPx - lensRPx*0.50,   // 左端寄り
      cyPx - lensRPx*0.47,   // 上端寄り
      lensRPx*0.19,
      lensRPx*0.12,
      -0.22,
      0,
      Math.PI*2
    );
    ctx.fill();
    ctx.restore();

    requestAnimationFrame(draw);
  }

  requestAnimationFrame(draw);
})();
</script>

<!-- ===== JS Tuner (autoCorrelate) ===== -->
<script>
(function(){
  'use strict';

  const NOTE_NAMES = ['C','C#','D','D#','E','F','F#','G','G#','A','A#','B'];
  const A4_REF = 440.0;
  const SHOW_DEBUG = false;

  function freqToNoteInfo(freq) {
    if (!freq || !Number.isFinite(freq) || freq <= 0) return null;
    const midi = Math.round(69 + 12 * Math.log2(freq / A4_REF));
    const noteName = NOTE_NAMES[(midi % 12 + 12) % 12];
    const octave = Math.floor(midi / 12) -1;
    const target = A4_REF * Math.pow(2, (midi - 69) / 12);
    const cents = 1200 * Math.log2(freq / target);
    return { note: noteName, oct: octave, cents };
  }

  let audioCtx    = null;
  let sourceNode  = null;
  let gainNode    = null;
  let analyser    = null;
  let running     = false;
  let confEMA     = 0;

  let lastLockFreq  = null;
  let lastLockNote  = "--";
  let lastLockCents = 0;
  let wasLocked = false;
  let lockReleaseTime = 0;
  const GRACE_PERIOD_MS = 500;

  const startBtn  = document.getElementById('startBtn');
  const statusEl  = document.getElementById('status');
  const metricsEl = document.getElementById('metrics');

  function autoCorrelate(buf, sampleRate) {
    const size = buf.length;
    let rms = 0;
    for (let i = 0; i < size; i++) {
      const v = buf[i];
      rms += v * v;
    }
    rms = Math.sqrt(rms / size);

    if (rms < 0.003) {
      return { freq: null, rms };
    }

    const minLag = Math.floor(sampleRate / 2000);
    const maxLag = Math.floor(sampleRate / 60);
    
    const correlations = new Float32Array(maxLag + 1);
    let maxCorr = 0;

    for (let lag = minLag; lag <= maxLag; lag++) {
      let corr = 0;
      const corrLen = size - lag;
      for (let i = 0; i < corrLen; i++) {
        corr += buf[i] * buf[i + lag];
      }
      correlations[lag] = corr / corrLen;
      if (correlations[lag] > maxCorr) maxCorr = correlations[lag];
    }

    if (maxCorr > 0) {
      for (let lag = minLag; lag <= maxLag; lag++) {
        correlations[lag] /= maxCorr;
      }
    }

    let foundZeroCross = false;
    let bestOffset = -1;

    for (let lag = minLag + 1; lag < maxLag - 1; lag++) {
      if (!foundZeroCross && correlations[lag - 1] < 0 && correlations[lag] >= 0) {
        foundZeroCross = true;
      }
      
      if (foundZeroCross) {
        if (correlations[lag] > correlations[lag - 1] && 
            correlations[lag] > correlations[lag + 1] &&
            correlations[lag] > 0.7) {
          
          const y1 = correlations[lag - 1];
          const y2 = correlations[lag];
          const y3 = correlations[lag + 1];
          const denom = y1 - 2 * y2 + y3;
          if (Math.abs(denom) > 1e-6) {
            const offset = (y1 - y3) / (2 * denom);
            bestOffset = lag + offset;
          } else {
            bestOffset = lag;
          }
          break;
        }
      }
    }

    if (bestOffset === -1) {
      return { freq: null, rms };
    }

    const freq = sampleRate / bestOffset;
    return { freq, rms };
  }

  function updateLoop() {
    if (!running || !analyser) return;

    const bufferLen = analyser.fftSize;
    const timeData = new Float32Array(bufferLen);
    analyser.getFloatTimeDomainData(timeData);

    const ac = autoCorrelate(timeData, audioCtx.sampleRate);
    let freq = ac.freq;
    let rms = ac.rms || 0;
    let db = rms > 0 ? 20 * Math.log10(rms) : -120;

    let noteText = "--";
    let cents = 0;
    let instConf = 0;

    if (freq && freq > 20 && freq < 5000) {
      const info = freqToNoteInfo(freq);
      if (info) {
        noteText = `${info.note}${info.oct}`;
        cents = info.cents;
      }

      const centsNorm = Math.min(50, Math.abs(cents));
      const centsScore = 1 - (centsNorm / 50);
      const dbClamp = Math.max(-80, Math.min(-10, db));
      const dbNorm = (dbClamp + 80) / 70;
      instConf = Math.max(0, Math.min(1, (centsScore * 0.7 + dbNorm * 0.3)));
    } else {
      freq = null;
    }

    const alpha = 0.15;
    confEMA = (1 - alpha) * confEMA + alpha * instConf;
    if (!isFinite(confEMA)) confEMA = 0;

    if (freq) {
      if (typeof window.setTunerFrequency === 'function') {
        window.setTunerFrequency(freq);
      }
    }
    window.dpConfEMA = confEMA;

    const lockedNow = (window.dpLocked === true);
    const nowTime = performance.now();

    const justLocked = lockedNow && !wasLocked;
    const justUnlocked = !lockedNow && wasLocked;

    if (justUnlocked) {
      lockReleaseTime = nowTime;
    }

    const inGracePeriod = (nowTime - lockReleaseTime) < GRACE_PERIOD_MS;

    if (freq && noteText !== "--" && confEMA > 0.3) {
      lastLockFreq  = freq;
      lastLockNote  = noteText;
      lastLockCents = cents;
    }

    if (justLocked && lastLockFreq === null) {
      const hudFreq = window.tunerFreq;
      if (hudFreq && hudFreq !== 440) {
        const hudInfo = freqToNoteInfo(hudFreq);
        if (hudInfo) {
          lastLockFreq = hudFreq;
          lastLockNote = `${hudInfo.note}${hudInfo.oct}`;
          lastLockCents = hudInfo.cents;
        }
      }
    }

    let dispFreq, dispNote, dispCents;

    if ((lockedNow || inGracePeriod) && lastLockFreq !== null) {
      dispFreq  = lastLockFreq.toFixed(2) + " Hz";
      dispNote  = lastLockNote;
      dispCents = lastLockCents.toFixed(2) + " cents";
    } else if (freq && noteText !== "--") {
      dispFreq  = freq.toFixed(2) + " Hz";
      dispNote  = noteText;
      dispCents = cents.toFixed(2) + " cents";
    } else if (!freq && lastLockFreq !== null) {
      dispFreq  = lastLockFreq.toFixed(2) + " Hz";
      dispNote  = lastLockNote;
      dispCents = lastLockCents.toFixed(2) + " cents";
    } else {
      dispFreq  = "--";
      dispNote  = "--";
      dispCents = "--";
    }

    wasLocked = lockedNow;

    let text = '';
    if (SHOW_DEBUG) {
      text +=
`RMS:   ${rms.toFixed(5)}
dBFS:  ${db.toFixed(1)}
Conf:  ${confEMA.toFixed(2)}\n`;
    }
    text +=
`Freq:  ${dispFreq}
Note:  ${dispNote}
Cents: ${dispCents}`;

    if (metricsEl) {
      metricsEl.textContent = text;
    }

    requestAnimationFrame(updateLoop);
  }

  async function initTuner() {
    if (running) return;

    startBtn.disabled = true;
    statusEl.textContent = 'Initializing…';

    try {
      statusEl.textContent = 'Requesting mic access…';

      const legacyGetUserMedia =
        navigator.getUserMedia ||
        navigator.webkitGetUserMedia ||
        navigator.mozGetUserMedia ||
        navigator.msGetUserMedia;

      const getUserMedia = (constraints) => {
        if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
          return navigator.mediaDevices.getUserMedia(constraints);
        } else if (legacyGetUserMedia) {
          return new Promise((resolve, reject) => {
            legacyGetUserMedia.call(navigator, constraints, resolve, reject);
          });
        } else {
          return null;
        }
      };

      const gUM = getUserMedia({
        audio: {
          channelCount: 1,
          echoCancellation: false,
          noiseSuppression: false,
          autoGainControl: false
        }
      });

      if (!gUM) {
        throw new Error('This browser cannot use the microphone on this device.');
      }

      const stream = await gUM;

      const AudioContextClass = window.AudioContext || window.webkitAudioContext;
      audioCtx = new AudioContextClass();

      if (audioCtx.state === 'suspended') {
        await audioCtx.resume();
      }

      sourceNode = audioCtx.createMediaStreamSource(stream);

      gainNode = audioCtx.createGain();
      const isMobile = /Android|webOS|iPhone|iPad|iPod/i.test(navigator.userAgent);
      gainNode.gain.value = isMobile ? 6.0 : 3.5;

      analyser = audioCtx.createAnalyser();
      analyser.fftSize = 2048;

      sourceNode.connect(gainNode);
      gainNode.connect(analyser);

      running = true;
      statusEl.textContent = isMobile
        ? 'Tuning… (Hold your phone near the instrument)'
        : 'Tuning…';

      requestAnimationFrame(updateLoop);

    } catch (err) {
      console.error('[ΔPhase] initTuner error:', err);
      statusEl.textContent = 'Error: ' + err.message + '\nHTTPS and microphone permission are required.';
      startBtn.disabled = false;
    }
  }

  startBtn.addEventListener('click', () => {
    initTuner();
  });
})();
</script>

</body>
</html>