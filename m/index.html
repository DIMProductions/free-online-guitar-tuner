<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Free Online Guitar & Instrument Tuner</title>
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <meta name="description" content="Free online tuner that runs in your browser. Supports guitar, bass, and other instruments using your device microphone. Real-time circular HUD with note, frequency (Hz), and cent deviation.">

  <style>
  * {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
  }

  body {
    height: 100vh;
    background: radial-gradient(ellipse at 30% 30%, #000 0%, #000 50%, #000 100%);
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    font-family: ui-monospace, "SF Mono", Menlo, Consolas, monospace;
    color: #e8f7ff;
  }

  .meter-pane,
  .circle-meter-container {
    position: relative;
    width: min(70vmin, 520px);
    aspect-ratio: 1;
  }

  .hud-canvas {
    position: absolute;
    inset: 0;
    width: 100%;
    height: 100%;
    display: block;
    filter: drop-shadow(0 0 18px rgba(43,108,255,0.45));
    z-index: 1;
  }

  .hud-ring {
    position: absolute;
    inset: 0;
    display: grid;
    place-items: center;
    pointer-events: none;
    filter: drop-shadow(0 0 10px rgba(0,255,255,0.12));
    z-index: 0;
  }

  .hud-ring > svg {
    width: 100%;
    height: 100%;
    display: block;
    transform-origin: 50% 50%;
    transform: scale(0.98);
  }

  .control-strip {
    width: 100%;
    max-width: 520px;
    margin-top: 20px;
    padding: 10px 12px 16px;
    border-radius: 999px;
    background:
      radial-gradient(circle at 0 0, rgba(0,180,255,0.12) 0, transparent 45%),
      radial-gradient(circle at 100% 100%, rgba(255,100,180,0.08) 0, transparent 50%),
      linear-gradient(135deg, #020712 0%, #050b16 50%, #020509 100%);
    border: 1px solid rgba(0,255,255,0.2);
    box-shadow:
      0 0 0 1px rgba(0,0,0,0.9),
      0 16px 40px rgba(0,0,0,0.85);
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 6px;
  }

  #startBtn {
    padding: 8px 18px;
    border-radius: 999px;
    border: 1px solid rgba(0,255,255,0.7);
    background:
      radial-gradient(circle at 30% 0%, #0b2f4a 0, #021017 42%, #000 100%);
    color: #e8f7ff;
    font-size: 13px;
    letter-spacing: 0.09em;
    text-transform: uppercase;
    text-shadow: 0 0 6px rgba(0,255,255,0.7);
    box-shadow:
      0 0 12px rgba(0,255,255,0.6),
      0 0 36px rgba(0,140,255,0.35);
    cursor: pointer;
    display: inline-flex;
    align-items: center;
    gap: 6px;
  }

  #startBtn:hover:not(:disabled) {
    box-shadow:
      0 0 16px rgba(0,255,255,0.85),
      0 0 42px rgba(0,140,255,0.5);
    transform: translateY(-0.5px);
  }

  #startBtn:disabled {
    opacity: 0.45;
    cursor: not-allowed;
    transform: none;
    box-shadow: none;
  }

  #status {
    font-size: 14px;
    color: #79bcd1;
    text-align: center;
  }

  #metrics {
    margin-top: 12px;
    font-size: 11px;
    color: #5a8a9a;
    text-align: center;
    font-family: ui-monospace, monospace;
    white-space: pre;
  }

  @media (max-width: 600px) {
    body {
      height: 100vh;
      padding: 12px 8px;
      justify-content: flex-start;
      gap: 16px;
    }

    .meter-pane,
    .circle-meter-container {
      width: 100%;
      max-width: 420px;
    }

    .control-strip {
      max-width: 420px;
      margin-top: 14px;
      padding: 8px 12px 12px;
      border-radius: 24px;
      gap: 4px;
    }

    #startBtn {
      width: 100%;
      justify-content: center;
      font-size: 12px;
      padding: 10px 12px;
    }

    #status {
      font-size: 12px;
    }

    #metrics {
      font-size: 10px;
    }
  }
  </style>
</head>
<body>

<div class="meter-pane">
  <div class="circle-meter-container">
    <canvas class="hud-canvas" id="hudCanvas"></canvas>

    <div class="hud-ring">
      <!-- ‚òÖ‚òÖ‚òÖ „Åì„Åì„Å´„Çµ„Éº„ÇØ„É´HUD„ÅÆSVG„ÇíÂÖ•„Çå„Çã ‚òÖ‚òÖ‚òÖ -->
    </div>
  </div>
</div>

<div class="control-strip">
  <button id="startBtn">TAP TO START TUNER</button>
  <div id="status">Idle</div>
  <div id="metrics"></div>
</div>

<!-- ===== Circle HUD ÊèèÁîª ===== -->
<script>
(function(){
  'use strict';

  const NOTE = ['C','C#','D','D#','E','F','F#','G','G#','A','A#','B'];
  const a4 = 440.0;
  const MAX_CENTS = 50;
  const MAX_ANG   = 60 * Math.PI / 180;
  const BASE_ANG  = -Math.PI / 2;

  const canvas = document.getElementById('hudCanvas');
  if (!canvas) return;

  const DPR = Math.min(1.75, window.devicePixelRatio || 1);
  const ctx = canvas.getContext('2d');

  function fit(){
    const r = canvas.getBoundingClientRect();
    canvas.width  = r.width  * DPR;
    canvas.height = r.height * DPR;
    ctx.setTransform(DPR,0,0,DPR,0,0);
  }
  fit();
  window.addEventListener('resize', fit);

  function clamp(v, lo, hi){ return Math.max(lo, Math.min(hi, v)); }
  function lowpass(prev, next, dt, hz){
    const a = 1 - Math.exp(-dt * hz * 2 * Math.PI);
    return prev + (next - prev) * clamp(a, 0, 1);
  }
  function isInRange(c){ return Math.abs(c) <= 5; }
  function RGBA(c, a){ return `rgba(${c.r},${c.g},${c.b},${a})`; }

  function analyze(f, a4ref){
    const midi = Math.round(69 + 12 * Math.log2(f / a4ref));
    const note = NOTE[(midi % 12 + 12) % 12];
    const oct  = Math.floor(midi / 12) -1;
    const target = a4ref * Math.pow(2, (midi - 69) / 12);
    const cents  = 1200 * Math.log2(f / target);
    return { note, oct, target, cents, adjCents: cents };
  }

  function needleAngleFromCents(c){
    return clamp((c / MAX_CENTS) * MAX_ANG, -MAX_ANG, MAX_ANG);
  }

  // HUD „ÅåË™≠„ÇÄ„Ç∞„É≠„Éº„Éê„É´
  window.tunerFreq = 440;
  window.setTunerFrequency = function(f){
    if (!Number.isFinite(f) || f <= 0) return;
    window.tunerFreq = f;
  };
  window.dpConfEMA = 0;
  window.dpLocked = false;

  function getFreq() { return window.tunerFreq || 440; }

  let tPrev = performance.now();
  let centsSm = 0;

  const centsSamples = [];
  const MAX_SAMPLES = 9;

  function pushCentsSample(c, conf){
    if (conf < 0.2) {
      centsSamples.length = 0;
      return;
    }
    centsSamples.push(c);
    if (centsSamples.length > MAX_SAMPLES) {
      centsSamples.shift();
    }
  }

  function getSmoothedCents(){
    if (centsSamples.length === 0) return 0;
    let sum = 0;
    for (let i = 0; i < centsSamples.length; i++){
      sum += centsSamples[i];
    }
    return sum / centsSamples.length;
  }

  let lockState = "idle";
  let lockEnterTime = 0;
  let lockLastGoodTime = 0;

  function updateLock(nowMs, baseLock, conf){
    const ok = baseLock && conf >= 0.12;
    if (ok) lockLastGoodTime = nowMs;

    if (lockState === "idle") {
      if (ok) {
        lockState = "locking";
        lockEnterTime = nowMs;
      }
    } else if (lockState === "locking") {
      if (!ok) {
        lockState = "idle";
      } else if (nowMs - lockEnterTime > 50) {
        lockState = "locked";
      }
    } else if (lockState === "locked") {
      if (nowMs - lockLastGoodTime > 450) {
        lockState = "idle";
      }
    }
    return lockState === "locked";
  }

  function draw(){
    const tNow = performance.now();
    const dt   = (tNow - tPrev) / 1000;
    tPrev = tNow;

    const freq = getFreq();
    const info = analyze(freq, a4);

    const w = canvas.width / DPR;
    const h = canvas.height / DPR;
    const cx = w * 0.5;
    const cy = h * 0.5;
    const r  = Math.min(w, h) * 0.46;

    const conf = clamp(window.dpConfEMA || 0, 0, 1);

    const rawCents = clamp(info.adjCents, -MAX_CENTS, MAX_CENTS);
    pushCentsSample(rawCents, conf);
    const smoothCents = getSmoothedCents();

    centsSm = lowpass(centsSm, smoothCents, dt, 4);

    const ang = needleAngleFromCents(centsSm);
    const baseLock = Math.abs(centsSm) <= 8;
    const locked = updateLock(tNow, baseLock, conf);

    window.dpLocked = locked;

    ctx.clearRect(0,0,w,h);

    ctx.save();
    ctx.translate(cx, cy);

    const grad = ctx.createRadialGradient(0,0,r*0.2, 0,0,r*0.95);
    grad.addColorStop(0.0, 'rgba(0, 10, 18, 1)');
    grad.addColorStop(0.4, 'rgba(2, 36, 64, 1)');
    grad.addColorStop(0.7, 'rgba(0, 0, 0, 1)');
    grad.addColorStop(1.0, 'rgba(0, 0, 0, 1)');
    ctx.fillStyle = grad;
    ctx.beginPath();
    ctx.arc(0,0,r*1.02,0,Math.PI*2);
    ctx.fill();

    const outerR = r * 0.98;
    ctx.strokeStyle = 'rgba(0,180,255,0.35)';
    ctx.lineWidth = 1.5;
    ctx.beginPath();
    ctx.arc(0,0,outerR,0,Math.PI*2);
    ctx.stroke();

    const inRange = isInRange(centsSm);

    const ringBaseR = r * 0.75;
    ctx.strokeStyle = inRange ? 'rgba(0,220,255,0.7)' : 'rgba(255,80,80,0.6)';
    ctx.lineWidth = locked ? 3.4 : 2.4;
    ctx.shadowColor = inRange ? 'rgba(0,220,255,0.5)' : 'rgba(255,0,0,0.6)';
    ctx.shadowBlur  = locked ? 20 : 10;
    ctx.beginPath();
    ctx.arc(0,0,ringBaseR,0,Math.PI*2);
    ctx.stroke();
    ctx.shadowBlur = 0;

    const tickR1 = r*0.80;
    const tickR2 = r*0.92;
    for (let deg = -60; deg <= 60; deg += 5){
      const tickAng = BASE_ANG + (deg * Math.PI / 180);
      const strength = 1 - Math.min(1, Math.abs(deg) / 65);
      const alpha = 0.12 + 0.5 * strength;
      const isMajor = (deg % 10 === 0);

      ctx.strokeStyle = `rgba(${inRange ? '0,200,255' : '255,90,90'},${alpha})`;
      ctx.lineWidth = isMajor ? 2.0 : 1.0;
      ctx.beginPath();
      ctx.moveTo(Math.cos(tickAng) * tickR1, Math.sin(tickAng) * tickR1);
      ctx.lineTo(Math.cos(tickAng) * tickR2, Math.sin(tickAng) * tickR2);
      ctx.stroke();
    }

    const markR = r * 0.98;
    ctx.strokeStyle = inRange 
      ? 'rgba(0,255,255,0.9)' 
      : 'rgba(255,80,80,0.9)';
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.moveTo(Math.cos(BASE_ANG) * markR * 0.94, Math.sin(BASE_ANG) * markR * 0.94);
    ctx.lineTo(Math.cos(BASE_ANG) * markR, Math.sin(BASE_ANG) * markR);
    ctx.stroke();

    const MAX_STROBE_SEG = 72;
    const strobeR0 = r * 0.57;
    const strobeR1 = r * 0.83;
    const angNeedle12 = BASE_ANG + ang;
    const focusSigma = locked ? 0.23 : 0.35;
    const dashAng = (Math.PI * 2) / MAX_STROBE_SEG * 0.7;

    for (let i = 0; i < MAX_STROBE_SEG; i++){
      const phi = -Math.PI + (i + 0.5) * ((Math.PI * 2) / MAX_STROBE_SEG) + BASE_ANG;
      const d   = Math.atan2(Math.sin(phi - angNeedle12), Math.cos(phi - angNeedle12));
      const weight = Math.exp(-(d * d) / (2 * focusSigma * focusSigma));
      const a0 = phi - dashAng * 0.7;
      const a1 = phi + dashAng * 0.5;

      const baseAlpha = locked ? 0.18 : 0.10;
      const addAlpha  = locked ? 0.85 : 0.80;

      ctx.strokeStyle = inRange
        ? RGBA({r:0, g:136, b:255}, baseAlpha + addAlpha * weight)
        : RGBA({r:255, g:0, b:0}, 0.12 + 0.78 * weight);
      ctx.lineWidth = r * 0.055 * (0.6 + 0.4 * weight);

      ctx.beginPath();
      ctx.arc(0, 0, strobeR0, a0, a1);
      ctx.stroke();

      ctx.beginPath();
      ctx.arc(0, 0, strobeR1, a0, a1);
      ctx.stroke();
    }

    const needleLen  = r * 0.78;
    const needleBack = r * 0.18;
    const needleAng  = BASE_ANG + ang;

    const baseCol = inRange ? {r:0,g:220,b:255} : {r:255,g:110,b:110};

    const tipX  = Math.cos(needleAng) * needleLen;
    const tipY  = Math.sin(needleAng) * needleLen;
    const tailX = Math.cos(needleAng + Math.PI) * needleBack;
    const tailY = Math.sin(needleAng + Math.PI) * needleBack;

    ctx.shadowColor = RGBA(baseCol, locked ? 0.55 : 0.3);
    ctx.shadowBlur  = locked ? 22 : 14;
    ctx.lineCap = 'round';

    ctx.lineWidth = 4.5;
    ctx.strokeStyle = RGBA({r:0,g:0,b:0}, 0.9);
    ctx.beginPath();
    ctx.moveTo(tailX * 0.96, tailY * 0.96);
    ctx.lineTo(tipX * 1.01, tipY * 1.01);
    ctx.stroke();

    const gradNeedle = ctx.createLinearGradient(tailX, tailY, tipX, tipY);
    const headCol = inRange ? 'rgba(0,255,255,1)' : 'rgba(255,160,160,1)';
    gradNeedle.addColorStop(0.0, 'rgba(0,0,0,0.0)');
    gradNeedle.addColorStop(0.25,'rgba(0,180,255,0.65)');
    gradNeedle.addColorStop(0.7, headCol);
    gradNeedle.addColorStop(1.0,'rgba(255,255,255,0.9)');

    ctx.lineWidth = 3.0;
    ctx.strokeStyle = gradNeedle;
    ctx.beginPath();
    ctx.moveTo(tailX, tailY);
    ctx.lineTo(tipX, tipY);
    ctx.stroke();
    ctx.shadowBlur = 0;

    ctx.fillStyle = 'rgba(0,0,0,0.9)';
    ctx.beginPath();
    ctx.arc(0, 0, r * 0.07, 0, Math.PI * 2);
    ctx.fill();

    const innerGrad = ctx.createRadialGradient(0,0,0,0,0,r*0.32);
    innerGrad.addColorStop(0.0, 'rgba(0,0,0,1)');
    innerGrad.addColorStop(0.5, 'rgba(0,40,80,1)');
    innerGrad.addColorStop(1.0, 'rgba(0,0,0,1)');
    ctx.fillStyle = innerGrad;
    ctx.beginPath();
    ctx.arc(0, 0, r * 0.38, 0, Math.PI * 2);
    ctx.fill();

    const info2 = analyze(freq, a4);

    ctx.fillStyle = '#e8f7ff';
    ctx.font = `${r*0.22}px "SF Mono", ui-monospace, Menlo, Consolas, monospace`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(`${info2.note}${info2.oct}`, 0, r * 0.10);

    ctx.fillStyle = 'rgba(120,200,255,0.9)';
    ctx.font = `${r*0.11}px "SF Mono", ui-monospace`;
    ctx.fillText(`${freq.toFixed(2)} Hz`, 0, -r * 0.10);

    ctx.restore();

    requestAnimationFrame(draw);
  }

  requestAnimationFrame(draw);
})();
</script>

<!-- ===== JS Tuner (autoCorrelate + updateLoop) ===== -->
<script>
(function(){
  'use strict';

  const NOTE_NAMES = ['C','C#','D','D#','E','F','F#','G','G#','A','A#','B'];
  const A4_REF = 440.0;
  const SHOW_DEBUG = false; // true„Å´„Åô„Çã„Å®RMS„Å®„Åã„ÇÇÂá∫„Åõ„Çã

  function freqToNoteInfo(freq) {
    if (!freq || !Number.isFinite(freq) || freq <= 0) return null;
    const midi = Math.round(69 + 12 * Math.log2(freq / A4_REF));
    const noteName = NOTE_NAMES[(midi % 12 + 12) % 12];
    const octave = Math.floor(midi / 12) -1;
    const target = A4_REF * Math.pow(2, (midi - 69) / 12);
    const cents = 1200 * Math.log2(freq / target);
    return { note: noteName, oct: octave, cents };
  }

  let audioCtx    = null;
  let sourceNode  = null;
  let gainNode    = null;
  let analyser    = null;
  let running     = false;
  let confEMA     = 0;

  const startBtn  = document.getElementById('startBtn');
  const statusEl  = document.getElementById('status');
  const metricsEl = document.getElementById('metrics');

  let lastFreq = 0; 

  // ===== Drop C# „ÉÅ„É•„Éº„Éã„É≥„Ç∞Âº¶„ÉÜ„Éº„Éñ„É´ =====
  // C#-G#-C#-F#-A#-C#
  const STRING_FREQS = [
    { name: "C#2", freq: 69.296, string: 6 },
    { name: "G#2", freq: 103.826, string: 5 },
    { name: "C#3", freq: 138.591, string: 4 },
    { name: "F#3", freq: 184.997, string: 3 },
    { name: "A#3", freq: 233.082, string: 2 },
    { name: "C#4", freq: 277.183, string: 1 },
  ];

  // Âº¶„É≠„ÉÉ„ÇØÁä∂ÊÖã
  let currentString = null;
  let sameStringCount = 0;
  const LOCK_THRESHOLD = 3;    // 3„Éï„É¨„Éº„É†„ÅßÂàùÂõû„É≠„ÉÉ„ÇØ
  const SWITCH_THRESHOLD = 5;  // 5„Éï„É¨„Éº„É†„ÅßÂº¶Âàá„ÇäÊõø„Åà

  // ÂÄçÈü≥„Åã„Çâ„Åß„ÇÇÂü∫Èü≥„Å´Èôç„Çä„Çã„Çπ„Éä„ÉÉ„Éó
  function snapToString(observedFreq) {
    if (!observedFreq || observedFreq < 40 || observedFreq > 800) return null;

    let best = null;
    let bestDiff = Infinity;

    for (const s of STRING_FREQS) {
      // Ë¶≥Ê∏¨„Åï„Çå„ÅüÂë®Ê≥¢Êï∞ / 1, /2, /4 „ÇíÂÖ®ÈÉ®Ë©¶„Åô
      const candFund1 = observedFreq;
      const candFund2 = observedFreq / 2;
      const candFund4 = observedFreq / 4;

      const d1 = Math.abs(candFund1 - s.freq);
      const d2 = Math.abs(candFund2 - s.freq);
      const d4 = Math.abs(candFund4 - s.freq);

      let useFund = candFund1;
      let useDiff = d1;

      if (d2 < useDiff) { useDiff = d2; useFund = candFund2; }
      if (d4 < useDiff) { useDiff = d4; useFund = candFund4; }

      if (useDiff < bestDiff) {
        bestDiff = useDiff;
        best = {
          name: s.name,
          stringNum: s.string,
          targetFreq: s.freq,
          fundFreq: useFund,
          rawFreq: observedFreq
        };
      }
    }

    if (!best) return null;

    // Âü∫Èü≥ÂÄôË£ú„Åå ¬±1.5ÂçäÈü≥‰ª•ÂÜÖ„Åò„ÇÉ„Å™„Åë„Çå„Å∞„Éé„Ç§„Ç∫„Å®„Åó„Å¶Êç®„Å¶„Çã
    const maxSemitone = 1.5;
    const maxRatio = Math.pow(2, maxSemitone / 12);

    if (best.fundFreq < best.targetFreq / maxRatio || best.fundFreq > best.targetFreq * maxRatio) {
      return null;
    }

    const cents = 1200 * Math.log2(best.fundFreq / best.targetFreq);
    best.cents = cents;
    return best;
  }

  function updateStringLock(snap) {
    if (!snap) {
      // Ê§úÂá∫Â§±Êïó„Å™„Çâ„Ç´„Ç¶„É≥„Éà„Å†„ÅëËêΩ„Å®„Åó„Å¶Áèæ„É≠„ÉÉ„ÇØ„ÅØÁ∂≠ÊåÅ
      if (sameStringCount > 0) sameStringCount--;
      if (currentString) {
        return {
          name: currentString.name,
          stringNum: currentString.stringNum,
          targetFreq: currentString.targetFreq,
          fundFreq: currentString.fundFreq || currentString.targetFreq,
          rawFreq: currentString.rawFreq || currentString.targetFreq,
          cents: currentString.cents || 0,
          locked: true
        };
      }
      return null;
    }

    if (!currentString || snap.name === currentString.name) {
      sameStringCount++;
      if (!currentString && sameStringCount >= LOCK_THRESHOLD) {
        currentString = {
          name: snap.name,
          stringNum: snap.stringNum,
          targetFreq: snap.targetFreq,
          fundFreq: snap.fundFreq,
          rawFreq: snap.rawFreq,
          cents: snap.cents
        };
        console.log('[STRING LOCK] Locked to:', snap.name);
      } else if (currentString && snap.name === currentString.name) {
        // „É≠„ÉÉ„ÇØ‰∏≠„ÅÆÊõ¥Êñ∞
        currentString.fundFreq = snap.fundFreq;
        currentString.rawFreq  = snap.rawFreq;
        currentString.cents    = snap.cents;
      }
    } else {
      sameStringCount = 1;
    }

    if (currentString && snap.name !== currentString.name && sameStringCount >= SWITCH_THRESHOLD) {
      currentString = {
        name: snap.name,
        stringNum: snap.stringNum,
        targetFreq: snap.targetFreq,
        fundFreq: snap.fundFreq,
        rawFreq: snap.rawFreq,
        cents: snap.cents
      };
      sameStringCount = 0;
      console.log('[STRING LOCK] Switched to:', snap.name);
    }

    if (currentString) {
      return {
        name: currentString.name,
        stringNum: currentString.stringNum,
        targetFreq: currentString.targetFreq,
        fundFreq: currentString.fundFreq || currentString.targetFreq,
        rawFreq: currentString.rawFreq || currentString.targetFreq,
        cents: currentString.cents || 0,
        locked: true
      };
    }

    return snap;
  }

  // ===== „ÇÆ„Çø„ÉºÁî®„É¨„É≥„Ç∏Âà∂Èôê‰ªò„Åç autoCorrelate =====
  function autoCorrelate(buf, sampleRate) {
    const size = buf.length;
    let rms = 0;
    for (let i = 0; i < size; i++) {
      const v = buf[i];
      rms += v * v;
    }
    rms = Math.sqrt(rms / size);

    // ÊÑüÂ∫¶„Ç¢„ÉÉ„ÉóÔºö„Åã„Å™„ÇäÂ∞è„Åï„ÅÑÈü≥„Åæ„ÅßÊãæ„ÅÜ
    if (rms < 0.0010) {  // ‚Üê 0.0025 „Åã„Çâ‰∏ã„Åí„Åü
      return { freq: null, rms, corr: 0 };
    }

    const MIN_FREQ = 40;   // ‰∏ãÈôê
    const MAX_FREQ = 500;  // ‰∏äÈôê

    const minLag = Math.floor(sampleRate / MAX_FREQ);
    const maxLag = Math.min(Math.floor(sampleRate / MIN_FREQ), Math.floor(size / 2));

    let bestOffset = -1;
    let bestCorrelation = 0;
    let foundGood = false;
    let lastCorrelation = 1;

    for (let lag = minLag; lag <= maxLag; lag++) {
      let correlation = 0;
      const corrLen = size - lag;
      for (let i = 0; i < corrLen; i++) {
        const diff = buf[i] - buf[i + lag];
        correlation += Math.abs(diff);
      }
      correlation = 1 - (correlation / corrLen); // 0„Äú1 „Å´Ê≠£Ë¶èÂåñ

      if (correlation > 0.75 && correlation > lastCorrelation) {
        foundGood = true;
      } else if (foundGood && correlation < lastCorrelation) {
        break;
      }

      if (correlation > bestCorrelation) {
        bestCorrelation = correlation;
        bestOffset = lag;
      }

      lastCorrelation = correlation;
    }

    if (bestOffset <= 0 || bestCorrelation < 0.1) {
      return { freq: null, rms, corr: 0 };
    }

    const freq = sampleRate / bestOffset;

    if (freq < MIN_FREQ || freq > MAX_FREQ) {
      return { freq: null, rms, corr: 0 };
    }

    return { freq, rms, corr: bestCorrelation };
  }

  function updateLoop() {
    if (!running || !analyser) return;

    const bufferLen = analyser.fftSize;
    const timeData = new Float32Array(bufferLen);
    analyser.getFloatTimeDomainData(timeData);

    const ac = autoCorrelate(timeData, audioCtx.sampleRate);
    let observedFreq = ac.freq;  // Áîü„ÅßË¶≥Ê∏¨„Åï„Çå„ÅüÂë®Ê≥¢Êï∞ÔºàÂÄçÈü≥„Åß„ÇÇOKÔºâ
    let rms = ac.rms || 0;
    let db = rms > 0 ? 20 * Math.log10(rms) : -120;

    // FenderÈ¢®ÔºöÂº¶„ÉÜ„Éº„Éñ„É´„Å´„Çπ„Éä„ÉÉ„ÉóÔºãÂÄçÈü≥‚ÜíÂü∫Èü≥
    const snap = snapToString(observedFreq);
    const stringInfo = updateStringLock(snap);

    let freq = null;      // HUD„Å´Ê∏°„Åô„ÄåÂü∫Èü≥Êé®ÂÆöÂÄ§„Äç
    let noteText = "--";
    let cents = 0;
    let instConf = 0;

    if (stringInfo) {
      const fundFreq = stringInfo.fundFreq || stringInfo.targetFreq;
      freq = fundFreq;
      noteText = stringInfo.name;
      cents = stringInfo.cents;

      const centsNorm = Math.min(50, Math.abs(cents));
      const centsScore = 1 - (centsNorm / 50);
      const dbClamp = Math.max(-80, Math.min(-10, db));
      const dbNorm = (dbClamp + 80) / 70;
      const lockBonus = stringInfo.locked ? 0.2 : 0;
      instConf = Math.max(0, Math.min(1, (centsScore * 0.6 + dbNorm * 0.2 + lockBonus)));
    } else {
      freq = null;
    }

    const alpha = 0.15;
    confEMA = (1 - alpha) * confEMA + alpha * instConf;
    if (!isFinite(confEMA)) confEMA = 0;

    if (freq) {
      if (typeof window.setTunerFrequency === 'function') {
        window.setTunerFrequency(freq);
      }
      lastFreq = freq;
    } else if (lastFreq) {
      if (typeof window.setTunerFrequency === 'function') {
        window.setTunerFrequency(lastFreq);
      }
    }

    window.dpConfEMA = confEMA;

    let text = '';
    if (SHOW_DEBUG) {
      text +=
`RMS:   ${rms.toFixed(5)}
dBFS:  ${db.toFixed(1)}
Conf:  ${confEMA.toFixed(2)}\n`;
    }
    text +=
`Freq:  ${freq ? freq.toFixed(2) + " Hz" : "--"}
Note:  ${noteText}
Cents: ${freq ? cents.toFixed(2) + " cents" : "--"}`;

    if (metricsEl) {
      metricsEl.textContent = text;
    }

    const wasLocked = window.dpLocked || false;

    const nowTime = performance.now();
    const TIME_LOCK_MS = 80;
    const TIME_UNLOCK_MS = 300;
    const GRACE_PERIOD_MS = TIME_UNLOCK_MS;

    if (!window._lockTimeState) {
      window._lockTimeState = {
        locked: false,
        lockStart: 0,
        unlockStart: 0,
        lastUpdate: nowTime
      };
    }

    const lockState = window._lockTimeState;

    if (confEMA > 0.35) {
      if (!lockState.locked) {
        if (!lockState.lockStart) {
          lockState.lockStart = nowTime;
        } else if (nowTime - lockState.lockStart >= TIME_LOCK_MS) {
          lockState.locked = true;
          lockState.unlockStart = 0;
        }
      }
    } else {
      if (lockState.locked) {
        if (!lockState.unlockStart) {
          lockState.unlockStart = nowTime;
        } else if (nowTime - lockState.unlockStart >= TIME_UNLOCK_MS) {
          lockState.locked = false;
          lockState.lockStart = 0;
        }
      } else {
        lockState.lockStart = 0;
      }
    }

    const lockedNow = lockState.locked;
    window.dpLocked = lockedNow;

    if (!window._lastLockInfo) {
      window._lastLockInfo = {
        freq: null,
        note: null,
        cents: 0,
        time: 0
      };
    }

    const lastLockInfo = window._lastLockInfo;

    let lastLockFreq = lastLockInfo.freq;
    let lastLockNote = lastLockInfo.note;
    let lastLockCents = lastLockInfo.cents;

    if (!window._lockReleaseTime) {
      window._lockReleaseTime = 0;
    }
    let lockReleaseTime = window._lockReleaseTime;

    const justLocked = lockedNow && !wasLocked;
    const justUnlocked = !lockedNow && wasLocked;

    if (justUnlocked) {
      lockReleaseTime = nowTime;
    }

    const inGracePeriod = (nowTime - lockReleaseTime) < GRACE_PERIOD_MS;

    if (freq && noteText !== "--" && confEMA > 0.3) {
      lastLockFreq  = freq;
      lastLockNote  = noteText;
      lastLockCents = cents;

      lastLockInfo.freq  = lastLockFreq;
      lastLockInfo.note  = lastLockNote;
      lastLockInfo.cents = lastLockCents;
      lastLockInfo.time  = nowTime;
    }

    if (!freq && inGracePeriod && lastLockFreq) {
      if (typeof window.setTunerFrequency === 'function') {
        window.setTunerFrequency(lastLockFreq);
      }
      const f = lastLockFreq;
      const info = freqToNoteInfo(f);
      if (info) {
        noteText = `${info.note}${info.oct}`;
      }
    }

    window._lockReleaseTime = lockReleaseTime;
    window._lastLockInfo    = lastLockInfo;
    window.dpLocked         = lockedNow;

    requestAnimationFrame(updateLoop);
  }

  async function initTuner() {
    if (running) return;

    startBtn.disabled = true;
    statusEl.textContent = 'Initializing‚Ä¶';

    try {
      statusEl.textContent = 'Requesting mic access‚Ä¶';

      const legacyGetUserMedia =
        navigator.getUserMedia ||
        navigator.webkitGetUserMedia ||
        navigator.mozGetUserMedia ||
        navigator.msGetUserMedia;

      const getUserMedia = (constraints) => {
        if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
          return navigator.mediaDevices.getUserMedia(constraints);
        } else if (legacyGetUserMedia) {
          return new Promise((resolve, reject) => {
            legacyGetUserMedia.call(navigator, constraints, resolve, reject);
          });
        } else {
          return null;
        }
      };

      const isMobile = /Android|webOS|iPhone|iPad|iPod/i.test(navigator.userAgent);
      console.log('[ŒîPhase] Mobile:', isMobile);

      const gUM = getUserMedia({
        audio: {
          channelCount: 1,
          echoCancellation: false,
          noiseSuppression: false,
          autoGainControl: false,
          sampleRate: isMobile ? 48000 : undefined,
          latency: isMobile ? 0.01 : undefined
        }
      });

      if (!gUM) {
        throw new Error('This browser cannot use the microphone on this device.');
      }

      const stream = await gUM;

      const AudioContextClass = window.AudioContext || window.webkitAudioContext;
      audioCtx = new AudioContextClass();

      if (audioCtx.state === 'suspended') {
        await audioCtx.resume();
      }

      sourceNode = audioCtx.createMediaStreamSource(stream);

      gainNode = audioCtx.createGain();
      gainNode.gain.value = isMobile ? 4.0 : 3.0; // ‚Üê „É¢„Éê„Ç§„É´ÊÑüÂ∫¶„Ç¢„ÉÉ„Éó

      analyser = audioCtx.createAnalyser();
      analyser.fftSize = isMobile ? 2048 : 4096;
      analyser.smoothingTimeConstant = 0;

      console.log('[ŒîPhase] Gain:', gainNode.gain.value, 'FFT:', analyser.fftSize, 'SR:', audioCtx.sampleRate);

      sourceNode.connect(gainNode);
      gainNode.connect(analyser);

      running = true;
      statusEl.textContent = isMobile 
        ? 'üé∏ Tuning... (Hold phone close to guitar)'
        : 'üé∏ Tuning...';

      requestAnimationFrame(updateLoop);

    } catch (err) {
      console.error('[ŒîPhase] initTuner error:', err);
      statusEl.textContent = 'Error: ' + err.message + '\nHTTPS and microphone permission are required.';
      startBtn.disabled = false;
    }
  }

  startBtn.addEventListener('click', () => {
    initTuner();
  });

})();
</script>

</body>
</html>
